
```` Selenium Notes ````

----------------------------------------------------------------------
Q: What is Selenium?
Answer:
Selenium is an open-source tool used for automating web applications for testing purposes. It automates browser actions, simulates user interactions, and supports multiple browsers and programming languages, making it widely used in automated testing.
----------------------------------------------------------------------
Q: How does Selenium architecture work?
Answer:
Selenium WebDriver operates with a Client-Server architecture. The client (test script) sends commands to the server (WebDriver) using the W3C Protocol. WebDriver then communicates with the browser driver (like ChromeDriver, GeckoDriver) to execute commands on the browser, sending back results to the client.

Difference between Selenium 3 and Selenium 4?  
   Selenium 4 introduces several enhancements:
     - Support for W3C WebDriver standard.
     - Improved browser compatibility.
     - Enhanced support for grid (Selenium Grid 4).
     - New APIs like relative locators.
     - Chrome DevTools integration for better control.
   Selenium 3 is based on the legacy WebDriver and doesn’t have some of these newer features.
----------------------------------------------------------------------
Q: What is the structure of Selenium?
Answer:
Selenium consists of the following components:
    1.	Selenium WebDriver: Automates browser actions.
    2.	Selenium IDE: Record and playback tool.
    3.	Selenium Grid: Enables parallel test execution on different machines.
    4.	Selenium Remote Server: Distributes test execution across environments.
    5.	Language Bindings: Supports various languages (Java, Python, C#, etc.).
----------------------------------------------------------------------
Q: What are the advantages of using Selenium?
Answer:
    • Open Source: Free to use, with strong community support.
    • Cross-Browser Compatibility: Supports all major browsers.
    • Multiple Language Support: Java, Python, C#, and others.
    • Integration: Works with frameworks like TestNG, JUnit, etc.
    • Parallel Testing: Selenium Grid allows tests to run concurrently across different browsers and machines.
----------------------------------------------------------------------
Q: What are the different types of locators in Selenium?
Answer:
Locators are methods used by Selenium to find and interact with elements on a web page. 
Different types of locators help identify elements uniquely or broadly based on their attributes or position.

Common Selenium Locators:
1. ID
    - Uses the element’s unique id attribute.
    - Fastest and most reliable locator if the ID is unique.
    ex: driver.findElement(By.id("elementId"))
2. Name
    - Uses the element’s name attribute.
    - Useful if id is not available.
    ex: driver.findElement(By.name("elementName"))
3. Class Name
    - Uses the CSS class attribute of elements.
    - Can match multiple elements, so use carefully.
    ex: driver.findElement(By.className("className"))
4. Tag Name
    - Finds elements by their HTML tag (e.g., input, button).
    - Useful for bulk operations or broad selection.
    ex: driver.findElement(By.tagName("tagName"))
5.Link Text
    - Matches a link (<a>) by its exact visible text.
    - Used to locate hyperlinks.
    ex: driver.findElement(By.linkText("linkText"))
6.Partial Link Text
    - Matches links by partial text.
    - Useful when exact link text is long or dynamic.
    ex: driver.findElement(By.partialLinkText("partialText"))
7.CSS Selector
    - Uses CSS syntax to locate elements via IDs, classes, attributes, and hierarchy.
    - Powerful and flexible.
    ex: driver.findElement(By.cssSelector("cssSelector"))
8.XPath
    - Uses XML path language to navigate and locate elements.
    - Most powerful and flexible locator, can select elements based on complex conditions and hierarchy.
    ex: driver.findElement(By.xpath("xpathExpression"))
----------------------------------------------------------------------
Q: What is the difference between findElement() and findElements()?
Answer:
•	findElement(): Returns the first matching element; throws NoSuchElementException if not found.
•	findElements(): Returns a list of matching elements; returns an empty list if no elements are found.
----------------------------------------------------------------------
Q: How do you handle dynamic web elements in Selenium?
Answer:
•	Waits: Use conditions like waitUntilElementVisible() to ensure the element is ready before interacting.
•	JavaScript Execution: If elements are dynamic, use JavaScript to interact.
•	Dynamic Locators: Use relative XPath or CSS selectors that adapt to changes in element attributes.
----------------------------------------------------------------------
Q: How do you handle alerts and pop-up windows in Selenium?
Answer:
    •	Switch to alert: driver.switchTo().alert()
    •	Accept alert: alert.accept()
    •	Dismiss alert: alert.dismiss()
    •	Get alert text: alert.getText()
    •	Prompt alert: Use alert.sendKeys() to input text into prompt dialogs.
----------------------------------------------------------------------
Q: How do you perform mouse actions in Selenium?
Answer:
Use the Actions class to perform mouse gestures like hovering, clicking, double-clicking, and drag-and-drop. 
Example:
    Actions actions = new Actions(driver);
    actions.moveToElement(driver.findElement(By.id("elementId"))).perform();
----------------------------------------------------------------------
Q: How do you handle file uploads in Selenium?
Answer:
For file uploads, use the sendKeys() method to interact directly with <input type="file"> elements:
    WebElement uploadButton = driver.findElement(By.id("fileUpload"));
    uploadButton.sendKeys("C:\\path\\to\\file.png");
----------------------------------------------------------------------
Q: How do you handle iframes in Selenium?
Answer:
Switch to an iframe using:
    driver.switchTo().frame("frameName");  // By name or ID
    driver.switchTo().frame(0);            // By index
After performing actions, switch back to the main content:
    driver.switchTo().defaultContent();
----------------------------------------------------------------------
Q: How do you take a screenshot in Selenium?
Answer:
Use the TakesScreenshot interface:
    File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
    FileUtils.copyFile(screenshot, new File("path/to/screenshot.png"));
----------------------------------------------------------------------
Q: How would you handle Selenium exceptions?
Answer:
Handle exceptions using try-catch blocks, retries with explicit waits, and logging for debugging.
----------------------------------------------------------------------
Q: How do you perform cross-browser testing in Selenium?
Answer:
Use different WebDriver implementations for each browser (e.g., ChromeDriver, FirefoxDriver) to perform tests across browsers. Selenium Grid also enables parallel test execution on different machines and browsers.
----------------------------------------------------------------------
Q: How do you implement a data-driven framework in Selenium?
Answer:
Store test data in external files (e.g., CSV, Excel) and use libraries (like Apache POI) to read data. Loop through the data using a @DataProvider or other data-driven techniques to run the tests with different input values.
----------------------------------------------------------------------
Q: How do you maximize the browser window in Selenium?
Answer:
Use the following code to maximize the browser window:
    driver.manage().window().maximize();
----------------------------------------------------------------------
Q: what are Relative locators in Selenium ?
Answer:
Relative locators help Locate elements based on their position relative to others using methods like above(), below(), toLeftOf(), toRightOf(), near().
----------------------------------------------------------------------
Q: What is a TimeoutException in Selenium and how do you handle it?
Answer:
TimeoutException happens when Selenium waits too long for a condition (like element clickable) but it doesn’t happen in given time.
Solution: Use Explicit Wait with a timeout and catch the exception to handle it gracefully.

try {
    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    WebElement element = wait.until(ExpectedConditions.elementToBeClickable(By.id("myElement")));
    element.click();
} catch (TimeoutException e) {
    System.out.println("Element not clickable within time.");
}
----------------------------------------------------------------------
Q: What is ElementClickInterceptedException and how can you fix it?
Answer:
This occurs when something (like a popup or overlay) blocks the element you want to click.
Solution: Wait for the element to be clickable, scroll it into view, close any overlays, or use JavaScript click.

try {
    WebElement element = driver.findElement(By.id("myElement"));
    element.click();
} catch (ElementClickInterceptedException e) {
    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    wait.until(ExpectedConditions.elementToBeClickable(element));
    ((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView(true);", element);
    ((JavascriptExecutor) driver).executeScript("arguments[0].click();", element);
}
----------------------------------------------------------------------
Q: What is NoSuchElementException and how do you handle it?
Answer:
Thrown when Selenium can’t find an element using the locator provided.
Solution: Use waits or verify locator correctness; catch the exception to retry or log

try {
    WebElement element = driver.findElement(By.id("myElement"));
    element.click();
} catch (NoSuchElementException e) {
    System.out.println("Element not found.");
}
----------------------------------------------------------------------
Q: What causes StaleElementReferenceException and how do you fix it?
Answer:
Happens when the referenced element is no longer attached to the current DOM (e.g., page refreshed).
Solution: Re-locate the element before interacting with it again.

try {
    WebElement element = driver.findElement(By.id("myElement"));
    element.click();
} catch (StaleElementReferenceException e) {
    element = driver.findElement(By.id("myElement"));
    element.click();
}
----------------------------------------------------------------------
Q: What is ElementNotInteractableException and how can you handle it?
Answer:
Occurs when an element is present but can’t be interacted with (hidden, disabled).
Solution: Use JavaScript click as a fallback.

try {
    WebElement element = driver.findElement(By.id("myElement"));
    element.click();
} catch (ElementNotInteractableException e) {
    JavascriptExecutor js = (JavascriptExecutor) driver;
    js.executeScript("arguments[0].click();", element);
}
----------------------------------------------------------------------
Q: What is JavaScriptExecutor? How do you use it?  
Answer:
JavaScriptExecutor is used to execute JavaScript in the context of the current browser.
Example usage:
    JavascriptExecutor js = (JavascriptExecutor) driver;
    js.executeScript("window.scrollBy(0,500)");
----------------------------------------------------------------------
Q: Explain the difference between checked and unchecked exceptions.
Answer:
Checked Exceptions are exceptions that must be handled using try-catch or declared using throws. The compiler checks for these at compile time.
    Example: IOException, SQLException

Unchecked Exceptions are exceptions that don’t have to be handled explicitly. The compiler doesn't force you to catch them. They usually happen due to programming mistakes.
    Example: NullPointerException, ArrayIndexOutOfBoundsException
----------------------------------------------------------------------
Q: Can you explain how to get values from a .properties file for configuration in Java?
Answer:
To read values from a .properties file in Java, follow these steps:
1.	Create a Properties object.
2.	Use a FileInputStream to open the .properties file.
3.	Load the file using the .load() method.
4.	Retrieve the value by calling .getProperty() with the key (e.g., browser or url).
This method helps externalize configuration, allowing easy modification of settings without changing the code.
----------------------------------------------------------------------
Q: How would you provide test data from a local .xlsx or .xls file into a TestNG test script?
Answer:
You can provide data using TestNG's @DataProvider to read data from an Excel file:
1.	Use Apache POI to open the file with a FileInputStream.
2.	Load the workbook using XSSFWorkbook for .xlsx files or HSSFWorkbook for .xls files.
3.	Access the sheet (XSSFSheet) and loop through its rows.
4.	Return the data in the form of an Object[][] array for TestNG to pass into the test method.
The @DataProvider will then supply the test data for each test method.
----------------------------------------------------------------------
Q: How do you handle synchronization in Selenium?
Answer:
Selenium provides three types of synchronization to ensure that scripts wait for elements to load or meet certain conditions:
1.	Implicit Wait: Sets a default time for Selenium to wait for elements 
    ex. driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
2.	Explicit Wait: Wait for a specific condition to be true for an element 
    ex. WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10)); 
        wait.until(ExpectedConditions.elementToBeClickable(element));
3.	Fluent Wait: Similar to Explicit Wait but with more flexibility, such as polling at intervals.
Synchronization is crucial for dynamic web pages where elements might take time to appear.
----------------------------------------------------------------------
Q: How do you handle closing the second window in Selenium?
Answer:
String mainWindow = driver.getWindowHandle();  // Step 1 :Get the handle of the main window

for (String handle : driver.getWindowHandles()) {  // Step 2 : Loop through all window handles
    if (!handle.equals(mainWindow)) {
        driver.switchTo().window(handle);          // Switch to second window
        driver.close();                            // Step 3: Close second window
    }
}
driver.switchTo().window(mainWindow);              // Step 4: Back to main window
----------------------------------------------------------------------
Q: How do you handle dropdowns in Selenium?  
Answer:
To handle dropdowns, Selenium provides the Select class:
   Select dropdown = new Select(driver.findElement(By.id("dropdown")));
   dropdown.selectByVisibleText("Option1");
   dropdown.selectByIndex(2);
   dropdown.selectByValue("optionValue");
----------------------------------------------------------------------
Q: What is the difference between get() and navigate().to()?  
Answer:
   - get(): Used to open a URL. It waits for the page to load before returning control.
   - navigate().to(): Used to navigate to a URL, but it doesn’t wait for the page to load in the same way get() does. It allows for backward and forward navigation as well.
----------------------------------------------------------------------
Q: What is the difference between driver.quit() and driver.close()?  
Answer:
    - driver.quit(): Closes all the browser windows opened by the WebDriver session and ends the session.
    - driver.close(): Closes the current browser window. If multiple windows are open, it closes only the current window.
----------------------------------------------------------------------
Q: How do you scroll a webpage using Selenium?  
Answer:
You can scroll using JavaScript:
    
    JavascriptExecutor js = (JavascriptExecutor) driver;
    js.executeScript("window.scrollBy(0,500)");
----------------------------------------------------------------------
Q: How do you capture network logs in Selenium?  
Answer:
 You can capture network logs by enabling performance logging using Chrome DevTools Protocol (CDP) in Selenium.

// Capture network logs
LogEntries logs = driver.manage().logs().get(LogType.PERFORMANCE);
for (LogEntry entry : logs) {
    System.out.println(entry.getMessage());
}
----------------------------------------------------------------------
Q: What is the role of Desired capabilities in Selenium? 
Answer: 
    Desired capabilities allow you to configure WebDriver properties like browser type, version, and operating system to customize the WebDriver’s behavior.
----------------------------------------------------------------------
Q: What are the different types of Assertions used in Selenium? 
Answer: 
    - Assert.assertEquals(expected, actual): Verifies if two values are equal.
    - Assert.assertTrue(condition): Verifies if the condition is true.
    - Assert.assertFalse(condition): Verifies if the condition is false.
    - Assert.assertNull(object): Verifies if the object is null.
    - Assert.assertNotNull(object): Verifies if the object is not null.
----------------------------------------------------------------------
Q: What are the limitations of Selenium WebDriver?
Answer:  
    - Cannot handle desktop applications.
    - Limited support for handling CAPTCHAs.
    - Limited support for browser-based pop-ups.
    - No built-in reporting features.
----------------------------------------------------------------------
Q: How do you run Selenium tests in headless mode?  
Answer:
You can run tests in headless mode by configuring the browser with headless options, for example:
    ChromeOptions options = new ChromeOptions();
    options.addArguments("--headless");
    WebDriver driver = new ChromeDriver(options);
----------------------------------------------------------------------
Q: How do you handle CAPTCHA in Selenium? is it Possible?  
Answer:
    Handling CAPTCHA is difficult since it's designed to prevent automation. You could use services like 2Captcha or AntiCaptcha to solve CAPTCHAs if needed.
----------------------------------------------------------------------
Q: What are Globs in Selenium, and how are they used?
Answer::
Globs are simple wildcard patterns used in Selenium IDE to match text or element attributes.
    '*' means any number of characters
    '?' means one character
They help handle dynamic values without complex regex.
Example: button_* matches button_1, button_submit.
----------------------------------------------------------------------
Q: What is a Regular Expression (Regex) and how is it useful in Selenium testing?
Answer:
Regex is a pattern language used to match complex text patterns. In Selenium, it helps validate or find dynamic text, like IDs or formats (emails, dates).
button_\d{3} matches button_123 or button_001
----------------------------------------------------------------------
Q: What is WebDriverManager?
Answer :
    WebDriverManager is a Java library that automatically manages browser drivers (e.g., ChromeDriver, GeckoDriver) for Selenium. It eliminates the need to manually download and set the path for drivers.
----------------------------------------------------------------------
Q: How do you check if a dropdown is multi-select?
Answer :
    Select select = new Select(driver.findElement(By.id("dropdown")));
    boolean isMulti = select.isMultiple();
----------------------------------------------------------------------
Q: How do you fetch all values from a dropdown and print them?
Answer :
    Select select = new Select(driver.findElement(By.id("dropdown")));
    for (WebElement option : select.getOptions()) {
        System.out.println(option.getText());
    }
----------------------------------------------------------------------
Q: Code to validate if a text is highlighted and underlined:
Answer: 
WebElement element = driver.findElement(By.id("highlightedText"));
String backgroundColor = element.getCssValue("background-color");
String textDecoration = element.getCssValue("text-decoration");

if (textDecoration.contains("underline") && backgroundColor != null) {
    System.out.println("Text is highlighted and underlined.");
}
----------------------------------------------------------------------
Q: How to perform right-click (context click)?
Answer:
    Actions action = new Actions(driver);
    WebElement element = driver.findElement(By.id("context"));
    action.contextClick(element).perform();
----------------------------------------------------------------------
Q: How can you execute Selenium test cases on a remote machine?
Answer:
To run Selenium tests remotely:
    - Start Selenium Grid or a cloud service like BrowserStack/Sauce Labs.
    - Use RemoteWebDriver instead of ChromeDriver:
        DesiredCapabilities caps = new DesiredCapabilities();
        caps.setBrowserName("chrome");
        WebDriver driver = new RemoteWebDriver(new URL("http://remote-server:4444/wd/hub"), caps);
This connects your test to the remote machine and executes there.
----------------------------------------------------------------------
Q: What approach would you take to identify and validate broken links on a web page?
Answer:
1. Collect all links:
    List<WebElement> links = driver.findElements(By.tagName("a"));
2. For each link, send HTTP HEAD request:
    HttpURLConnection conn = (HttpURLConnection) new URL(link).openConnection();
    conn.setRequestMethod("HEAD");
    if (conn.getResponseCode() >= 400) {
        System.out.println("Broken link: " + link);
    }
Links returning HTTP 4xx or 5xx status codes are considered broken.
----------------------------------------------------------------------
Q: How can you implement retry logic in TestNG to handle flaky tests caused by temporary issues like network delays or browser glitches?
Answer:
we can implement retry logic in TestNG using a Retry Analyzer, which automatically re-executes failed tests without manual intervention. Here's how:

Step 1: Create a Retry Class
public class RetryAnalyzer implements IRetryAnalyzer {
    int count = 0;
    int maxTry = 2;

    public boolean  (ITestResult result) {
        if (count < maxTry) {
            count++;
            return true;
        }
        return false;
    }
}

Step 2: Attach the Retry Analyzer to Your Test
@Test(retryAnalyzer = RetryAnalyzer.class)
public void flakyTest() {
    // flaky logic here
}

For global retry logic, integrate this with ITestListener in your base test class or listener class. Instead of rerunning the whole suite, handle flaky tests smartly with TestNG’s built-in retry mechanism.
----------------------------------------------------------------------